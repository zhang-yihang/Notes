- [C++](#c)
  - [程序的内存模型](#程序的内存模型)
    - [代码区](#代码区)
    - [全局区](#全局区)
    - [栈区](#栈区)
    - [堆区](#堆区)
  - [引用](#引用)
    - [基本语法与实质](#基本语法与实质)
    - [引用作为函数的参数](#引用作为函数的参数)
    - [函数返回引用](#函数返回引用)
  - [函数进阶](#函数进阶)
    - [函数的默认参数](#函数的默认参数)
    - [函数的重载](#函数的重载)
  - [类](#类)
  - [封装](#封装)
  - [继承](#继承)
  - [重载运算符](#重载运算符)
  - [多态](#多态)
    - [虚函数](#虚函数)
  - [模板](#模板)
  - [STL](#stl)
# C++
在C的基础上引入面向对象编程
## 程序的内存模型
### 代码区
存放二进制代码，由操作系统管理  
### 全局区
存放全局变量、静态变量、全局常量
### 栈区
存放局部变量、局部常量、函数参数  
由编译器开辟和释放，无需人为操作  
而由于栈区的空间一旦函数调用完毕，就自动被编译器释放，所以不要返回栈区的地址。  
### 堆区
由程序员开辟释放，如果不手动释放，程序结束后，操作系统释放  
```
int *p = new int(10); //值为10储存在堆区，地址返回给p
delete p;

int *array = new int[10];
delete[] p;
```

## 引用
### 基本语法与实质
引用在创建的适合必须初始化，且后期不可更改  
```
int a=10;
int& b=a; //b,a的地址相同，相当于同一个地址，有两个名字
```
实质上，引用就是指针的简写  
```
int& b=a; <=> int* const b =&a;
b=10; <=> *b=10;
```
### 引用作为函数的参数
```
int a =10;
int b =20;
//直接值传递，失败
void swap1(int a,int b)
{
  int temp = a;
  a=b;
  b=temp;
}
swap1(a,b);
//地址传递，成功
void swap2(int* a,int* b)
{
  int temp=*a;
  *a=*b;
  *b=temp;
}
swap2(&a,&b);
//引用，成功
void swap(int& a,int& b)
{
  int temp=a;
  a=b;
  b=temp;
}
swap(a,b);
```
### 函数返回引用
下面的做法是错误的，因为a是局部变量，储存在栈区，函数执行完就释放内存，无法找到数据
```
int& test()
{
  int a=10;
  return a;
}
int& b=test();
```
正确做法如下
```
int& test()
{
  static int a=10;
  return a;
}
int& b=test();
test()=20; //test()是a的引用，b也是a的引用，此时a这个地址有两个别名。
```

## 函数进阶
### 函数的默认参数
```
函数的默认参数只能出现在函数声明或者函数定义中，二者选一，不可全部都有。  
int sum(int a,int b=10,int c=20) //第一个默认参数后面必须都是默认参数
{
  return a+b+c;
}
int a=sum(10);
int b=sum(10,3);
int c=sum(1,2,3);
```
### 函数的重载
函数重载需要满足三个条件  
* 两个函数在同一个作用域
* 两个函数名相同
* 函数的参数个数或者类型或者顺序不同,函数的返回值不可以作为重载的条件

```
int func()
{
  cout<<"this is func"<<endl;
}

int func(int a)
{
  cout<<"func2"<<endl;
}
```

## 类
## 封装
## 继承
## 重载运算符
## 多态
### 虚函数
## 模板
## STL