- [C++](#c)
  - [程序的内存模型](#程序的内存模型)
    - [代码区](#代码区)
    - [全局区](#全局区)
    - [栈区](#栈区)
    - [堆区](#堆区)
  - [引用](#引用)
    - [基本语法与实质](#基本语法与实质)
    - [引用作为函数的参数](#引用作为函数的参数)
    - [函数返回引用](#函数返回引用)
  - [函数进阶](#函数进阶)
    - [函数的默认参数](#函数的默认参数)
    - [函数的重载](#函数的重载)
  - [类](#类)
    - [封装](#封装)
      - [类的基本形式](#类的基本形式)
      - [类的权限](#类的权限)
      - [成员属性一般设为私有](#成员属性一般设为私有)
    - [对象的初始化与释放](#对象的初始化与释放)
      - [构造函数与析构函数](#构造函数与析构函数)
      - [构造函数分类与调用](#构造函数分类与调用)
      - [拷贝构造函数的调用](#拷贝构造函数的调用)
      - [编译器对构造函数的建立规则](#编译器对构造函数的建立规则)
      - [深拷贝与浅拷贝](#深拷贝与浅拷贝)
    - [继承](#继承)
    - [重载运算符](#重载运算符)
    - [多态](#多态)
      - [虚函数](#虚函数)
  - [模板](#模板)
  - [STL](#stl)
# C++
在C的基础上引入面向对象编程
## 程序的内存模型
### 代码区
存放二进制代码，由操作系统管理  
### 全局区
存放全局变量、静态变量、全局常量
### 栈区
存放局部变量、局部常量、函数参数  
由编译器开辟和释放，无需人为操作  
而由于栈区的空间一旦函数调用完毕，就自动被编译器释放，所以不要返回栈区的地址。  
### 堆区
由程序员开辟释放，如果不手动释放，程序结束后，操作系统释放  
```
int *p = new int(10); //值为10储存在堆区，地址返回给p
delete p;

int *array = new int[10];
delete[] p;
```

## 引用
### 基本语法与实质
引用在创建的适合必须初始化，且后期不可更改  
```
int a=10;
int& b=a; //b,a的地址相同，相当于同一个地址，有两个名字
```
实质上，引用就是指针的简写  
```
int& b=a; <=> int* const b =&a;
b=10; <=> *b=10;
```
### 引用作为函数的参数
```
int a =10;
int b =20;
//直接值传递，失败
void swap1(int a,int b)
{
  int temp = a;
  a=b;
  b=temp;
}
swap1(a,b);
//地址传递，成功
void swap2(int* a,int* b)
{
  int temp=*a;
  *a=*b;
  *b=temp;
}
swap2(&a,&b);
//引用，成功
void swap(int& a,int& b)
{
  int temp=a;
  a=b;
  b=temp;
}
swap(a,b);
```
### 函数返回引用
下面的做法是错误的，因为a是局部变量，储存在栈区，函数执行完就释放内存，无法找到数据
```
int& test()
{
  int a=10;
  return a;
}
int& b=test();
```
正确做法如下
```
int& test()
{
  static int a=10;
  return a;
}
int& b=test();
test()=20; //test()是a的引用，b也是a的引用，此时a这个地址有两个别名。
```

## 函数进阶
### 函数的默认参数
```
函数的默认参数只能出现在函数声明或者函数定义中，二者选一，不可全部都有。  
int sum(int a,int b=10,int c=20) //第一个默认参数后面必须都是默认参数
{
  return a+b+c;
}
int a=sum(10);
int b=sum(10,3);
int c=sum(1,2,3);
```
### 函数的重载
函数重载需要满足三个条件  
* 两个函数在同一个作用域
* 两个函数名相同
* 函数的参数个数或者类型或者顺序不同,函数的返回值不可以作为重载的条件

```
int func()
{
  cout<<"this is func"<<endl;
}

int func(int a)
{
  cout<<"func2"<<endl;
}
```

## 类
### 封装
#### 类的基本形式
```
class Circle
{
    public:
    int m_R;
    double cal()
    {
        return 2*3.14*m_R;
    }

};
//Circle是类，里面的变量和函数都是类的成员，也叫成员变量和成员函数
```
#### 类的权限
* public  类内类外都可以访问
* protected  只有类内可以访问，但是可以继承  
* private  只有类内可以访问，不可以继承
**struct和class的区别是**class默认私有权限，struct默认公有权限
#### 成员属性一般设为私有
优点：
* 可以控制读写权限
* 可以检测写入数据的有效性  
[代码示例](code/1_class_fenzhuang.cpp)

### 对象的初始化与释放
#### 构造函数与析构函数
构造函数与析构函数不需要调用，随着对象的创建和销毁自动运行，如果不写，则编译器会自动创建空的构造与析构  
#### 构造函数分类与调用
分为无参构造、有参构造、拷贝构造  
[demo](code/2_class_gouzao.cpp)  
#### 拷贝构造函数的调用
一般拷贝构造函数的调用出现在下面三个情形：  
* 利用拷贝构造函数初始化另一个对象
* 将对象放入函数参数中传递时（传递时其实是创建里新的对象，参考函数的形参。）（如果不想拷贝，则用引用）
* 将对象作为函数返回值传递时（因为返回时其实是将原来的局部对象销毁，复制到新的对象中）
#### 编译器对构造函数的建立规则
1. 无参构造
2. 有参构造
3. 拷贝构造
程序员不写，编译器负责123  
程序员1，编译器23  
程序员12，编译器3  
程序员123，编译器不写  
所以，如果程序员写了3，必须也写12，不然类就缺少默认构造。  
#### 深拷贝与浅拷贝
浅拷贝：编译器生成的拷贝构造函数默认是浅拷贝，但是会遇到一个问题，简单的赋值遇到堆区的数据就会导致重复释放内存。  
深拷贝：如果有数据存在堆区，就要自己写拷贝构造函数，并且在堆区新开辟空间，进行拷贝。  
### 继承
### 重载运算符
### 多态
#### 虚函数

## 模板

## STL